import { Editor, Location, Node, Operation, Path, Transforms } from 'slate';
import { YjsEditor } from '../src/plugin/yjsEditor';
import * as Y from 'yjs';
import { applySlateOps as applySlateOperations } from '../src/apply';
import { SyncElement } from '../src/model';

export interface TestEditor extends YjsEditor {
  shouldCaptureYjsUpdates: boolean;
  capturedYjsUpdates: Uint8Array[];
  onChangeComplete: () => void;
}

export type TransformFunc = ((e: Editor) => void);

export const TestEditor = {
  /**
   * Apply slate ops to Yjs
   */
  applySlateOpsToYjs: (e: TestEditor, operations: Operation[]) => {
    e.doc.transact(() => {
      applySlateOperations(e.syncDoc, operations);
    });
  },

  /**
   * Capture Yjs updates generated by this editor.
   */
  captureYjsUpdate: (e: TestEditor, update: Uint8Array, _origin: any) => {
    if (!e.shouldCaptureYjsUpdates) return;
    e.capturedYjsUpdates.push(update);
  },

  /**
   * Return captured Yjs updates.
   */
  getCapturedYjsUpdates: (e: TestEditor): Uint8Array[] => {
    const result = e.capturedYjsUpdates;
    e.capturedYjsUpdates = [];
    return result;
  },

  /**
   * Apply one Yjs update to Yjs.
   */
  applyYjsUpdateToYjs: (
    e: TestEditor,
    update: Uint8Array
  ): Promise<unknown> => {
    return new Promise((resolve, reject) => {
      e.shouldCaptureYjsUpdates = false;
      e.onChangeComplete = () => {
        e.onChangeComplete = () => void {};
        resolve();
      };
      try {
        Y.applyUpdate(e.doc, update);
      } catch (err) {
        reject(err);
      }
      e.shouldCaptureYjsUpdates = true;
    }).catch((err) => {
      fail(err);
    });
  },

  /**
   * Apply multiple Yjs updates to Yjs.
   */
  applyYjsUpdatesToYjs: async (e: TestEditor, updates: Uint8Array[]) => {
    updates.map(async (update) => {
      await TestEditor.applyYjsUpdateToYjs(e, update);
    });
  },

  /** 
   * Apply one TransformFunc to slate.
   */
  applyTransform: async (e: TestEditor, transform: TransformFunc): Promise<unknown> => {
    return new Promise((resolve, reject) => {
      e.onChangeComplete = () => {
        e.onChangeComplete = () => void {};
        resolve();
      };
      try {
        transform(e);
      } catch (err) {
        reject(err);
      }
    }).catch((err) => {
      fail(err);
    });
  },

  /** 
   * Apply multiple TransformFuncs to slate.
   */
  applyTransforms: async (e: TestEditor, transforms: TransformFunc[]) => {
    transforms.map(async (transform) => {
      await TestEditor.applyTransform(e, transform);
    });
  },

  makeInsertText: (text: string, at: Location): TransformFunc => {
    return (e: Editor) => {
      Transforms.insertText(e, text, { at });
    };
  },

  makeRemoveCharacters: (count: number, at: Location): TransformFunc => {
    return (e: Editor) => {
      Transforms.delete(e, { distance: count, at });
    };
  },

  makeInsertNodes: (nodes: Node | Node[], at: Location): TransformFunc => {
    return (e: Editor) => {
      Transforms.insertNodes(e, nodes, { at });
    };
  },

  makeMergeNodes: (at: Path): TransformFunc => {
    return (e: Editor) => {
      Transforms.mergeNodes(e, { at });
    };
  },

  makeMoveNodes: (from: Path, to: Path): TransformFunc => {
    return (e: Editor) => {
      Transforms.moveNodes(e, { at: from, to: to });
    };
  },

  makeRemoveNodes: (at: Path): TransformFunc => {
    return (e: Editor) => {
      Transforms.removeNodes(e, { at });
    };
  },

  makeSetNodes: (at: Location, props: Partial<Node>): TransformFunc => {
    return (e: Editor) => {
      Transforms.setNodes(e, props, { at });
    };
  },

  makeSplitNodes: (at: Location): TransformFunc => {
    return (e: Editor) => {
      Transforms.splitNodes(e, { at });
    };
  },
};

export const withTest = <T extends Editor>(editor: T): T & TestEditor => {
  const e = editor as T & TestEditor;

  const doc = new Y.Doc();
  const syncDoc = doc.getArray<SyncElement>('content');

  doc.on('update', (updateMessage: Uint8Array, origin: any) => {
    TestEditor.captureYjsUpdate(e, updateMessage, origin);
  });
  syncDoc.observeDeep((events) => {
    YjsEditor.applyEvents(e, events);
  });

  e.doc = doc;
  e.syncDoc = syncDoc;
  e.isRemote = false;
  e.shouldCaptureYjsUpdates = true;
  e.capturedYjsUpdates = [];

  const { onChange } = editor;
  e.onChange = () => {
    if (!e.isRemote) {
      TestEditor.applySlateOpsToYjs(e, e.operations);
    }

    if (onChange) {
      onChange();
    }

    if (e.onChangeComplete) {
      e.onChangeComplete();
    }
  };

  return e;
};
